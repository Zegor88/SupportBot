# Эпик E5: Retrieval (RAG) - Декомпозиция Задачи

## 1. Обзор и Цели

**Эпик:** E5. Retrieval (RAG)
**Цель:** Интегрировать механизм извлечения релевантной информации из векторной базы знаний (RAG) для обогащения контекста, передаваемого в `AnswerAgent`. Это позволит боту давать более точные и полные ответы, основанные на внутренней базе знаний.
**Критерий выполнения (Done-критерий из PRD):** `top-3 Q&A < 200 мс`.
**Ключевые компоненты:** `RetrieverAgent` (на базе `DocumentRetriever`), `FAISS`, `OpenAIEmbeddings`, `AnswerAgent`.

---

## 2. Декомпозиция Задач

Ниже представлен список задач для реализации эпика. Задачи упорядочены по приоритету и зависимостям.

### Задача 1: Создание `RetrieverAgent` и интеграция `DocumentRetriever`

- **Описание:** Создать нового агента `RetrieverAgent`, который будет инкапсулировать логику извлечения контекста. Основная логика будет взята из уже существующей утилиты `src/utils/rag_retriever.py`.
- **Приоритет:** **Высокий**
- **Зависимости:** Отсутствуют.
- **Предлагаемое решение:**
    1.  Создать новый файл `src/bot_agents/retriever_agent.py`.
    2.  В нем определить класс `RetrieverAgent`. Этот класс будет являться оберткой над `DocumentRetriever`.
    3.  `RetrieverAgent` должен инициализировать экземпляр `DocumentRetriever` при старте, загружая векторную базу данных `FAISS`. Путь к базе должен браться из конфигурации.
    4.  Реализовать в `RetrieverAgent` основной асинхронный метод, например, `retrieve_context(query: str) -> Optional[str]`, который будет вызывать `document_retriever.get_relevant_context(query)`.
    5.  Экспортировать `RetrieverAgent` из `src/bot_agents/__init__.py`.
    6.  В главном файле `handlers.py` создать и инициализировать экземпляр `RetrieverAgent`.

### Задача 2: Реализация обрезки контекста по токенам

- **Описание:** В существующем методе `DocumentRetriever.get_relevant_context` отсутствует логика ограничения размера контекста по количеству токенов. Необходимо добавить эту функциональность, чтобы избежать превышения лимитов LLM.
- **Приоритет:** **Высокий**
- **Зависимости:** Задача 1.
- **Предлагаемое решение:**
    1.  Модифицировать метод `get_relevant_context` в `src/utils/rag_retriever.py`.
    2.  Использовать библиотеку `tiktoken` (стандарт для моделей OpenAI) для подсчета токенов.
    3.  После получения отсортированного списка релевантных документов итеративно добавлять их содержимое в итоговый контекст, пока не будет достигнут лимит `max_tokens` (из `RAG_SETTINGS`).
    4.  Необходимо аккуратно обрабатывать случай, когда даже один документ превышает лимит. В этом случае можно либо обрезать сам документ, либо его проигнорировать. Оптимальный вариант - обрезать.

### Задача 3 [ЗАВЕРШЕНО]: Интеграция `RetrieverAgent` в `handle_text_message`

- **Описание:** Встроить вызов `RetrieverAgent` в основной обработчик сообщений, чтобы контекст извлекался перед вызовом `AnswerAgent`.
- **Приоритет:** **Высокий**
- **Зависимости:** Задача 1, Задача 2.
- **Предлагаемое решение:**
    1.  Открыть `src/bot/handlers.py`.
    2.  Найти блок, где обрабатывается `action: reply` с `system_prompt_key` (перед вызовом `AnswerAgent`).
    3.  В этом блоке добавить асинхронный вызов: `context_str = await retriever_agent.retrieve_context(text)`.
    4.  Передать полученный `context_str` в `ReplyHandoffData` при его создании: `handoff_data = ReplyHandoffData(..., context=context_str)`.
    5.  Обернуть вызов `retriever_agent` в блок `try...except`, чтобы сбои в работе RAG не прерывали основной поток. В случае ошибки, в `context` передавать `None`, а ошибку логировать.

### Задача 4: Обновление `build_answer_prompt` для использования контекста

- **Описание:** Модифицировать функцию сборки промпта, чтобы она корректно использовала полученный из RAG контекст вместо заглушки.
- **Приоритет:** **Высокий**
- **Зависимости:** Задача 3.
- **Предлагаемое решение:**
    1.  Открыть `src/prompts/builders.py`.
    2.  В функции `build_answer_prompt` найти строку `rag_context_str = handoff_data.context or "No additional context provided."`.
    3.  Убрать `TODO: [E5]` и оставить логику как есть. Она уже корректно обрабатывает случай, когда контекст есть (`handoff_data.context` будет содержать строку) и когда его нет (`None`, что приведет к использованию "No additional context provided.").
    4.  Можно улучшить текст, если контекст не найден, например: `"Relevant information from the knowledge base was not found."`.

### Задача 5: Подготовка и валидация данных для RAG

- **Описание:** Необходимо убедиться, что файл `answers_table.pkl` (или аналогичный, содержащий FAISS-индекс) существует, актуален и доступен для загрузки. Если его нет, нужно создать скрипт для его генерации.
- **Приоритет:** **Средний**
- **Зависимости:** Отсутствуют.
- **Предлагаемое решение:**
    1.  Проверить наличие `answers_table.pkl` в `data/vector_store` (или где он должен лежать согласно `VECTOR_STORE_PATH`).
    2.  Создать в директории `scripts/` новый скрипт, например, `create_vector_store.py`.
    3.  Этот скрипт должен:
        -   Читать исходные данные (например, из CSV или JSON файла с парами Q&A).
        -   Использовать `OpenAIEmbeddings` для векторизации текстов.
        -   Создавать индекс `FAISS` на основе этих векторов.
        -   Сохранять индекс в файл с помощью `faiss.save_local()`.
    4.  Добавить в `README.md` инструкцию по запуску этого скрипта для первоначальной настройки проекта.

### Задача 6: Тестирование и оценка производительности

- **Описание:** Провести комплексное тестирование RAG-пайплайна, включая проверку релевантности ответов и измерение производительности.
- **Приоритет:** **Средний**
- **Зависимости:** Все предыдущие задачи.
- **Предлагаемое решение:**
    1.  **Функциональное тестирование:**
        -   Подготовить список тестовых запросов, для которых в базе знаний точно есть релевантные ответы.
        -   Отправить запросы боту и проверить, что в логах `AnswerAgent` получает корректный контекст.
        -   Проверить, что ответы бота стали более полными и точными.
    2.  **Тестирование "пустого" ответа:**
        -   Отправить запрос на тему, которой нет в базе знаний.
        -   Убедиться, что бот отвечает адекватно (например, "Не удалось найти информацию...") и не "галлюцинирует".
    3.  **Измерение производительности:**
        -   Добавить логирование времени выполнения для метода `retriever_agent.retrieve_context`.
        -   Прогнать серию запросов и убедиться, что среднее время выполнения укладывается в целевой показатель < 200 мс (согласно PRD). 