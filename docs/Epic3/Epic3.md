# Эпик 3: Router & Dynamic Instructions

**Done-критерий:** 100% сообщений получают верный `action` (`reply`/`forward`/`drop`) в соответствии с YAML-правилами.

**Ключевые задачи из PRD:** YAML-rules store; RouterAgent; команда `/reload_rules`; пересылка в `dst_chat_id`.

*Примечание: Основой этого эпика является `RouterAgent` (задача E3.2), который будет реализовываться с использованием OpenAI Agent SDK. Последующие агенты (например, `AnswerAgent` из Эпика 5) также будут использовать SDK. Задачи, такие как E3.1, являются подготовительными и создают необходимую инфраструктуру и данные для этих агентов.*

---

## Декомпозированные Задачи:

### [ЗАВЕРШЕНО] E3.1: Определение схемы YAML-правил и создание менеджера правил
*Примечание: Эта задача создает основу для `RouterAgent` (E3.2). Сам `RulesManager` является стандартным Python-компонентом и напрямую не использует OpenAI Agent SDK, но предоставляет данные для агента, который будет его использовать.*

*   **E3.1.1:** Определить и задокументировать схему для `rules.yaml`.
    *   Поля правила: `rule_id` (строка, уник.), `priority` (число, для порядка), `conditions` (список объектов условий), `action` (enum: `reply`, `forward`, `drop`), `action_params` (словарь, зависит от `action`):
        *   Для `action: "reply"`: Может содержать `response_text: str` (для немедленного ответа заранее заданным текстом) ИЛИ `system_prompt_key: str` (ключ для системного промпта, который будет использован `AnswerAgent`). Если указан `response_text`, он имеет приоритет.
        *   Для `action: "forward"`: Должен содержать `destination_chat_id: str`.
        *   Для `action: "drop"`: `action_params` может быть пустым.
    *   Типы условий: `keyword_match` (список ключевых слов, тип совпадения: `any`/`all`, учет регистра), `regex_match` (шаблон regex). Рассмотреть возможность добавления более сложных условий при необходимости.
*   **E3.1.2:** Создать Pydantic модели для правил и условий для валидации.
*   **E3.1.3:** Реализовать класс `RulesManager` (`rules_manager.py`):
    *   Метод для загрузки правил из `rules.yaml`.
    *   Валидация правил при загрузке с использованием Pydantic моделей.
    *   Метод для получения отсортированного списка правил (по `priority`).
    *   Метод `reload_rules()` для перезагрузки правил из файла.
*   **E3.1.4:** Создать пример файла `rules.yaml`. Этот файл должен включать:
    *   Правила, основанные на предоставленном `instructions.txt` и примере `SYSTEM_PROMPT` для "Hamster Combat", включая:
        *   Отдельное правило для запросов о выводе средств из Hamster Combat (Rule 2.1 из примера `SYSTEM_PROMPT`).
        *   Отдельное правило для других запросов поддержки по Hamster Combat (Rule 2.2 из примера `SYSTEM_PROMPT`).
        *   Учесть исключение для общих/сравнительных вопросов (правила должны быть достаточно специфичны, чтобы не срабатывать на них, или использовать более низкий `priority` для общих ответов).
    *   Примеры правил для других сценариев, демонстрирующие `forward` и `drop` действия.

### [ЗАВЕРШЕНО] E3.2: Реализация `RouterAgent`
*   **E3.2.1:** Создать класс `RouterAgent(agents.Agent)` в `src/agents/router_agent.py`.
    *   Конструктор принимает экземпляр `RulesManager`.
*   **E3.2.2:** Реализовать основную логику агента в методе `async run(self, context: AgentContext, message_text: str, user_history: list) -> RouterDecision`:
    *   Получение правил от `RulesManager`.
    *   Итерация по правилам и применение `conditions` к `message_text` (и, возможно, `user_history`).
    *   Определение первого совпавшего правила (с учетом `priority`).
    *   Если правило не найдено, определить поведение по умолчанию (например, `reply` с дефолтным `system_prompt_key` или специальный `action: "default_reply"`).
*   **E3.2.3:** Определить структуру `RouterDecision` (например, Pydantic модель), возвращаемую `RouterAgent`, содержащую: `action: Literal["reply", "forward", "drop", "default_reply"]`, `matched_rule_id: Optional[str]`, `params: Optional[dict]` (e.g. `response_text`, `system_prompt_key`, `dst_chat_id`).

### [ЗАВЕРШЕНО] E3.3: Реализация действий (Reply Handoff, Forward Tool, Drop)
*   **E3.3.1: Действие `drop`**:
    *   `RouterAgent` возвращает `RouterDecision` с `action="drop"`. Основной цикл обработки прекращает дальнейшую работу с сообщением.
*   **E3.3.2: Действие `forward`**:
    *   Создать инструмент `telegram_forward_message_tool(bot, original_message_id: int, from_chat_id: int, target_chat_id: str, text: str)` в `src/tools/telegram_tools.py`.
        *   Инструмент использует экземпляр `telegram.Bot` для пересылки (или отправки копии) сообщения.
    *   Зарегистрировать этот инструмент в `RouterAgent`.
    *   Когда `RouterAgent` решает "forward", он подготавливает аргументы и вызывает этот инструмент.
*   **E3.3.3: Действие `reply` (прямой ответ или подготовка к Handoff)**:
    *   Когда `RouterAgent` определяет действие "reply":
        *   Если в `action_params` совпавшего правила есть `response_text`, `RouterAgent` формирует `RouterDecision` с `action="reply"` и `params` содержащими этот `response_text`. Этот текст будет отправлен пользователю напрямую, без участия `AnswerAgent`.
        *   Если в `action_params` есть `system_prompt_key` (и нет `response_text`), `RouterAgent` формирует `RouterDecision` с `action="reply"` и `params` содержащими этот `system_prompt_key`.
    *   Продумать и описать данные, которые будут передаваться в `AnswerAgent` через `handoff()` в случае, если требуется генерация ответа LLM. Pydantic модель `ReplyHandoffData(BaseModel): user_message: str, history: list, system_prompt: str` (или `system_prompt_key`).
    *   Интегрировать вызов `handoff(agent=answer_agent_placeholder, input_type=ReplyHandoffData, ...)` в вызывающий код после получения решения от `RouterAgent`, если `RouterDecision` предполагает генерацию ответа через `AnswerAgent`. `answer_agent_placeholder` будет заменен на реальный `AnswerAgent` в Эпике 5.

### [ЗАВЕРШЕНО] E3.4: Реализация команды `/reload_rules`
*   **E3.4.1:** Добавить обработчик команды `/reload_rules` в `src/handlers.py` (или где определены Telegram-хендлеры).
*   **E3.4.2:** Обработчик команды должен вызывать метод `rules_manager.reload_rules()`.
*   **E3.4.3:** Обеспечить обратную связь пользователю о результате выполнения команды (успех/ошибка загрузки).

### E3.5: Интеграция `RouterAgent` в основной поток обработки сообщений
*   **E3.5.1:** В главном обработчике сообщений (`main.py` или `handlers.py`), после `ValidatorAgent` (из Эпика 2), вызывать `RouterAgent.run()`.
*   **E3.5.2:** Анализировать `RouterDecision` от `RouterAgent`:
    *   Если `drop`, завершить обработку.
    *   Если `forward`, вызвать соответствующий инструмент.
    *   Если `reply` (или `default_reply`), инициировать `handoff` к `AnswerAgent` (или его заглушке) с подготовленными данными.

### E3.6: Логирование и Трассировка для `RouterAgent`
*   **E3.6.1:** Расширить логирование (FR-13) для записи решений `RouterAgent`: `ts`, `uid`, `matched_rule_id` (если есть), `action` (reply/forward/drop), `q` (исходное сообщение), `params` (например, `dst_chat_id`).
*   **E3.6.2:** Использовать встроенный механизм трассировки OpenAI Agent SDK.
    *   При необходимости добавить кастомные "spans" с помощью `trace()` или `custom_span()` внутри `RouterAgent` для детализации процесса принятия решения (например, `rule_evaluation_span`, `action_execution_span`).

### E3.7: Тестирование `RouterAgent`
*   **E3.7.1:** Написать unit-тесты для `RulesManager` (загрузка, валидация, перезагрузка правил).
*   **E3.7.2:** Написать unit-тесты для `RouterAgent`:
    *   Тестирование логики сопоставления правил с различными сообщениями и конфигурациями правил.
    *   Тестирование корректности выбора действия (`reply`, `forward`, `drop`) и формирования `RouterDecision`.
    *   Тестирование обработки случая, когда ни одно правило не совпадает.
*   **E3.7.3:** Написать интеграционные тесты для команды `/reload_rules`.
*   **E3.7.4:** Написать тесты для инструмента `telegram_forward_message_tool` (возможно, с использованием mock `telegram.Bot`).

---
Это детальный план. Если у вас есть какие-либо корректировки или дополнительные пожелания, дайте знать! 

---

## User Stories для Эпика 3:

1.  **US1: Управление правилами маршрутизации**
    *   **Как:** Контент-менеджер (или Администратор бота)
    *   **Я хочу:** Определять, изменять и дополнять правила маршрутизации сообщений в простом и понятном YAML-файле.
    *   **Чтобы:** Я мог(ла) гибко настраивать логику поведения бота для различных типов запросов пользователей без необходимости изменения кода и перезапуска бота.

2.  **US2: Определение условий срабатывания правил**
    *   **Как:** Контент-менеджер
    *   **Я хочу:** Задавать условия для каждого правила, используя совпадения по ключевым словам (с опциями "любое из" / "все из") и регулярным выражениям.
    *   **Чтобы:** Бот мог точно определять, к какому типу относится запрос пользователя и какое правило следует применить.

3.  **US3: Задание приоритетов для правил**
    *   **Как:** Контент-менеджер
    *   **Я хочу:** Назначать приоритеты для правил.
    *   **Чтобы:** В случае, если сообщение пользователя соответствует условиям нескольких правил, система однозначно выбирала наиболее релевантное правило.

4.  **US4: Настройка действий для правил (прямой ответ, пересылка, игнорирование)**
    *   **Как:** Контент-менеджер
    *   **Я хочу:** Для каждого правила указывать одно из следующих действий:
        *   `reply`: ответить заранее заготовленным текстом.
        *   `forward`: переслать сообщение в другой указанный Telegram-чат.
        *   `drop`: проигнорировать сообщение.
    *   **Чтобы:** Бот мог корректно обрабатывать запросы, предоставляя быстрые ответы на типовые вопросы, перенаправляя специфичные запросы экспертам или отсеивая нерелевантные сообщения.

5.  **US5: Настройка действия "Ответить с помощью AI"**
    *   **Как:** Контент-менеджер
    *   **Я хочу:** Для правила с действием `reply` иметь возможность указать, что ответ должен быть сгенерирован AI-агентом (`AnswerAgent`), передав ему ключ к соответствующему системному промпту.
    *   **Чтобы:** Сложные или нестандартные запросы обрабатывались интеллектуальным агентом с использованием нужного контекста и инструкций.

6.  **US6: "Горячая" перезагрузка правил**
    *   **Как:** Администратор бота (или Контент-менеджер с соответствующими правами)
    *   **Я хочу:** Инициировать перезагрузку YAML-файла с правилами с помощью Telegram-команды (`/reload_rules`).
    *   **Чтобы:** Изменения в логике маршрутизации вступали в силу немедленно, без необходимости остановки и перезапуска всего бота.

7.  **US7: Валидация синтаксиса правил**
    *   **Как:** Разработчик бота (при первоначальной настройке) и Контент-менеджер (при редактировании правил)
    *   **Я хочу:** Чтобы система автоматически проверяла синтаксис и структуру YAML-файла с правилами при его загрузке или перезагрузке.
    *   **Чтобы:** Минимизировать ошибки конфигурации и обеспечить стабильную работу маршрутизатора.

8.  **US8: Обработка по умолчанию**
    *   **Как:** Разработчик бота
    *   **Я хочу:** Чтобы `RouterAgent` имел определённое поведение по умолчанию (например, передача запроса `AnswerAgent` с общим системным промптом), если ни одно из настроенных правил не сработало.
    *   **Чтобы:** Каждый запрос пользователя получал какой-либо отклик, даже если он не подпадает под конкретные правила.

9.  **US9: Логирование решений маршрутизатора**
    *   **Как:** Администратор бота / Разработчик
    *   **Я хочу:** Чтобы все решения, принятые `RouterAgent` (какое правило сработало, какое действие выполнено, параметры действия), логировались.
    *   **Чтобы:** Я мог(ла) отслеживать корректность работы маршрутизации, анализировать поток запросов и выявлять узкие места или необходимость корректировки правил. 